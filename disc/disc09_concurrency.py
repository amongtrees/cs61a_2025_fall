import asyncio
# import time

# """ Generated by Gemini, check out the difference of outputs between two code snippets """
# # 辅助函数：获取当前时间，精确到毫秒
# def now():
#     return time.strftime("%H:%M:%S")

# async def wait_for(name, seconds):
#     # 1. 打印开始时间
#     print(f"[{now()}] 任务 {name} 启动了，即使需要睡 {seconds} 秒...")
    
#     # 2. 关键点：交出控制权，开始睡觉
#     await asyncio.sleep(seconds)
    
#     # 3. 打印结束时间
#     print(f"[{now()}] 任务 {name} 醒来了！")

# async def main():
#     print(f"--- 程序开始于 {now()} ---")
    
#     # asyncio.gather 让这三个任务“并发”启动
#     # 我们故意设置不同的睡眠时间，方便观察
#     # await asyncio.gather(
#     #     wait_for("A", 2), # A 睡 2秒
#     #     wait_for("B", 1), # B 睡 1秒
#     #     wait_for("C", 3)  # C 睡 3秒
#     # )

#     # 这是一个反面教材：串行执行
#     await wait_for("A", 2)
#     await wait_for("B", 1)
#     await wait_for("C", 3)
    
#     print(f"--- 程序结束于 {now()} ---")

# asyncio.run(main())

class Status:
    """A Status represents whether some operation is complete.

    >>> s = Status()
    >>> s.is_done()
    False
    >>> s.done()
    >>> s.is_done()
    True
    """
    def __init__(self):
        self.finish = False

    def is_done(self) -> bool:
        return self.finish

    def done(self):
        self.finish = True

import sys

async def get_user_input(status: Status) -> str:
    # Read one line of user input
    # Using "await" means that we're giving up control
    # and letting other coroutines run while we wait for
    # user input.
    result = await asyncio.to_thread(sys.stdin.readline)
    status.done() # Update status
    return result

# s = Status()
# print(asyncio.run(get_user_input(s)))

async def timer_example():
    """An example of using a timer.

    >>> asyncio.run(timer_example())
    0 seconds have passed...
    0.5 seconds have passed...
    1 second has passed...
    1.5 seconds have passed...
    Status updated after 1.7 seconds
    The timer counted up to 2.0 seconds
    """
    async def update_status(status: Status):
        await asyncio.sleep(1.7)
        print('Status updated after 1.7 seconds')
        status.done()

    status = Status()
    _, elapsed = await asyncio.gather(update_status(status), timer(status, 0.5))
    print(f'The timer counted up to {elapsed} seconds')

async def timer(status: Status, period):
    """Print a message every period seconds until status.is_done()."""
    time_passed = 0
    while not status.finish:
        if time_passed == 1:
            print('1 second has passed...')
        else:
            print(f'{time_passed} seconds have passed...')
        time_passed += period
        await asyncio.sleep(period)
    return time_passed

async def wwpd(challenge: str):
    """Run a WWPD interface.

    >>> simulate_user_input(5, 2.5) # simulate a user entering 5 after 2.5 seconds
    >>> asyncio.run(wwpd('2 + 3'))
    What is 2 + 3
    0 seconds have passed...
    1 second has passed...
    2 seconds have passed...
    5
    The user waited 3 seconds to correctly respond with 5

    >>> simulate_user_input(6, 1.5) # simulate a user entering 6 after 1.5 seconds
    >>> asyncio.run(wwpd('2 + 3'))
    What is 2 + 3
    0 seconds have passed...
    1 second has passed...
    6
    The user waited 2 seconds to incorrectly respond with 6
    """
    print('What is', challenge)
    "*** YOUR CODE HERE ***"
    s = Status()
    seconds, response = await asyncio.gather(timer(s, 1), get_user_input(s))
    # Get the correct answer, and compare it to the user input.
    correct_answer = eval(challenge)
    if str(correct_answer) == response.strip():
        print(f'The user waited {seconds} seconds to correctly respond with {response}')
    else:
        print(f'The user waited {seconds} seconds to incorrectly respond with {response}')

def simulate_user_input(response, time):
    """Simulate a user response after an amount of time. This is just for testing."""
    async def f(status):
        await asyncio.sleep(time)
        status.done()
        print(response)
        return str(response)
    global get_user_input
    get_user_input = f

def race_example():
    """Run an example with a simulated user input.

    >>> race_example()
    >>> print(asyncio.run(run_challenge("fake human")))
    -- Good job fake human; you correctly evaluated '1 + 1' --
    -- Good job fake human; you correctly evaluated '[1, 2].append([5, 6])' --
    -- Good job computer; you correctly evaluated '1 + 1' --
    -- Not quite fake human. Try to evaluate '[1, 2] + [5, 6]' again! --
    -- Good job computer; you correctly evaluated '[1, 2] + [5, 6]' --
    -- Not quite fake human. Try to evaluate '[1, 2] + [5, 6]' again! --
    {'1 + 1': 'fake human', '[1, 2].append([5, 6])': 'fake human', '[1, 2] + [5, 6]': 'computer'}
    """
    # Swap this simulated "fake human" response function for the one that gets input
    async def mock_get_input_from_user(expression):
        if expression in ['1 + 1', '[1, 2].append([5, 6])']:
            await asyncio.sleep(0.1)
            return str(eval(expression))
        else:
            await asyncio.sleep(0.2)
            return 'incorrect'
    global get_input_from_user
    get_input_from_user = mock_get_input_from_user


def get_next_expression(expressions, first) -> str:
    """ Return the lowest index expression in expressions that's not in first,
        or an empty string if all expressions are in first.

    >>> get_next_expression(['1 + 1', '[1, 2] + [5, 6]'], {})
    '1 + 1'
    >>> get_next_expression(['1 + 1', '[1, 2] + [5, 6]'], {'1 + 1': 'John'})
    '[1, 2] + [5, 6]'
    >>>
    >>> get_next_expression(['1 + 1'], {'1 + 1': 'John'})
    ''
    """
    "*** YOUR CODE HERE ***"
    if expressions is None:
        return ''
    for expression in expressions:
        if expression not in first.keys():
            return expression
    return ''

async def run_challenges(name: str, get_result, expressions: list[str], first: dict[str, str]):
    expression = get_next_expression(expressions, first)
    while expression != '':
        result = await get_result(expression)

        correct_answer = str(eval(expression))
        if result.strip() == correct_answer:
            print(f"-- Good job {name}; you correctly evaluated '{expression}' --")
            "*** YOUR CODE HERE ***"
            if expression not in first.keys():
                first[expression] = name
        else:
            print(f"-- Not quite {name}. Try to evaluate '{expression}' again! --")
        "*** YOUR CODE HERE ***"
        expression = get_next_expression(expressions, first)

async def get_input_from_user(expression):
    print('What does the following Python expression evaluate to', expression)
    return await asyncio.to_thread(sys.stdin.readline)

async def get_input_from_computer(expression: str):
    """Return the result of evaluating the expression, after 0.3 seconds."""
    await asyncio.sleep(0.3)
    return str(eval(expression))

async def run_challenge(player: str):
    """ Return a dictionary mapping each expression to the player name that evaluated it first.
        One player reads from stdin using the get_input_from_user coroutine and has name player, and the other
        is named 'computer' and gets input using get_input_from_computer."""
    expressions = ['1 + 1', '[1, 2].append([5, 6])', '[1, 2] + [5, 6]']
    "*** YOUR CODE HERE ***"
    first = {}
    await asyncio.gather(run_challenges(player, get_input_from_user, expressions, first), run_challenges('computer', get_input_from_computer, expressions, first))
    return first